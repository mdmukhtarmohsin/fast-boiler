import typer
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from rich.console import Console
from rich.panel import Panel

# --- Setup ---
app = typer.Typer()
console = Console()
try:
    TEMPLATE_DIR = Path(__file__).parent / "templates"
    env = Environment(loader=FileSystemLoader(TEMPLATE_DIR), trim_blocks=True, lstrip_blocks=True)
except Exception:
    console.print("[bold red]Error: 'templates' directory not found.[/bold red]")
    raise typer.Exit()

# --- Helper Functions ---
def render_template(template_name: str, context: dict) -> str:
    """Renders a Jinja2 template with the given context."""
    return env.get_template(template_name).render(context)

def create_resource_files(name: str, base_path: Path, context: dict):
    """Helper function to create all files for a new resource."""
    context["name"] = name
    context["ClassName"] = name.capitalize()
    context["plural_name"] = name + "s"
    
    template_map = {
        "models/model.py.j2": f"models/{name}_model.py",
        "schemas/schema.py.j2": f"schemas/{name}_schema.py",
        "repositories/base_repo.py.j2": "repositories/base_repo.py",
        "repositories/repo.py.j2": f"repositories/{name}_repo.py",
        "services/service.py.j2": f"services/{name}_service.py",
        "controllers/controller.py.j2": f"controllers/{name}_controller.py",
        "controllers/dependencies.py.j2": "controllers/dependencies.py",
    }
    
    for template, output_file in template_map.items():
        (base_path / output_file).write_text(render_template(template, context))

# --- CLI Commands ---
@app.command()
def init():
    """
    Initializes a new, production-ready FastAPI project.
    """
    console.print(Panel.fit("ðŸš€ [bold green]Fast Boiler: Project Initialization[/bold green]"))
    
    project_name = typer.prompt("What is the name of your project?")
    
    context = {"project_name": project_name}
    console.print("\n[bold cyan]Project Configuration:[/bold cyan]")
    context["is_async"] = typer.confirm("â–¶ Use asynchronous (async/await) code?", default=True)
    
    # Defaulting to SQLite for a simple, file-based setup
    db_choice = "sqlite"
    context["db_choice"] = db_choice
    
    if context["is_async"]:
        context["db_driver"] = "aiosqlite"
        context["db_url"] = f"sqlite+aiosqlite:///./app.db"
    else: # Sync
        context["db_driver"] = "" # Not needed for sync sqlite
        context["db_url"] = f"sqlite:///./app.db"

    console.print(f"\nâœ… Configuration complete. Generating project '[bold]{project_name}[/bold]'...")
    
    root_path = Path(project_name)
    app_path = root_path / "app"
    
    # Create directory structure
    dirs_to_create = ["controllers", "models", "repositories", "schemas", "services"]
    for dir_name in dirs_to_create:
        (app_path / dir_name).mkdir(parents=True, exist_ok=True)
        (app_path / dir_name / "__init__.py").touch()
    (app_path / "__init__.py").touch()
    
    # Generate core files
    (app_path / "database.py").write_text(render_template("database.py.j2", context))
    (root_path / ".gitignore").write_text(render_template("gitignore.j2", {}))
    (root_path / "requirements.txt").write_text(render_template("requirements.txt.j2", context))
    # Add a simple README for the generated project
    (root_path / "README.md").write_text(f"# {project_name}\n\nProject generated by fast-boiler.")


    # Generate the default 'user' resource
    create_resource_files("user", base_path=app_path, context=context)
    
    # Generate main.py
    context["default_resource"] = "user"
    (app_path / "main.py").write_text(render_template("main.py.j2", context))
    
    console.print("\n[bold green]âœ“ Project generation complete![/bold green]")
    console.print("\nTo get started:")
    console.print(f"  [cyan]cd {project_name}[/cyan]")
    console.print("  [cyan]python3 -m venv venv[/cyan]")
    console.print("  [cyan]source venv/bin/activate[/cyan]")
    console.print("  [cyan]pip install -r requirements.txt[/cyan]")
    console.print("  [cyan]uvicorn app.main:app --reload[/cyan]\n")

@app.command()
def generate(name: str):
    """
    Generates the files for a new resource. (This feature is under development)
    """
    console.print(f"ðŸ“¦ [yellow]Generating resource: {name} (feature coming soon)[/yellow]")


if __name__ == "__main__":
    app()